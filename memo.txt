i처음만난리액트 
=====섹션0
- SPA : Single Page Application
매 페이지가 달리 있는게 아니라 그 안에 들어가는 콘텐츠를 바꿔끼는 것 
- Script Language : 
런타임에 따라 실행된다. 
- 일치 연산자
a===b : a와b가 값과 자료형 모두 같음
a!==b : a와b의 값은 같으나 자료형은 다름
- 함수
function statement :
    function name(){ return }
arrow function expression :
    const name = () => { return }
======섹션1
리액트란?
    2013년에 출시되었고, 지금은 JS에서 가장 많이 사용되는 UI 라이브러리다. 
    앵귤러는 더 이상 공식적인 지원이 끊겼다. 
    Vue는 2014년에 출시된 프레임워크
프레임워크 vs 라이브러리
프레임워크 : 제어권한이 프레임워크에 있고, 
라이브러리 : 제어권한인 개발자에게 있다. 
=====섹션3
- jsx의 정의와 역할
    jsx = js + xml/html 의 약자 
    예시 : const element = <h1> hello, world </h1>;
    const element라는 js와 <h1></h1> 라는 html이 결합된 것이 바로 jsx 다. 
- jsx의 역할과 사용 이유
    내부적으로 xml/html을 js로 변환되어 사용한다. 변환에 사용되는 것이 바로
    React.createElement() 다. 해당 함수의 결과를는 아래와 같은 객체가 생성된다. 
    const 변수명 = {
        type: 태그, 
        props : [{
            id:value
        }], 
        children : [{}]
    }

    - jsx 와 일반js 비교
    (jsx)
    const element = {
        <h1 className = 'greeting'>Hello, world!</h1>
    }
    (js)
    const element = React.createElement('h1', {className : 'greeting'}, 'Hello, world!' )

    React.createElement() 를 통해 jsx가 js변환된다는 것은, 리액트에서 반드시 jsx를 쓰지 않아도 된다는 것이다. 
    직접 js를 사용해서 개발해도 된다. 다만 jsx를 사용하면 훨씬 편리해진다. 
- jsx의 장점
    - 간결한 코드
    - 높은 가독성
    - injection attack 방어
- jsx 사용법
    html코드 사이에 js 문법을 사용하고 싶을 때 {} 를 통해 작성한다. 
    (예시)
        function formatUser(user){
            return user.firstname + '' + user.lastName;
        }
        const element = (
            <h1>Hello, {formatUser(user)}</h1>
        )
        ReactDOM.render(
            element, 
            document.getElementById('root')
        )
    (태크의 속성에 값을 넣는 방법)
        1. 큰따옴표 사이에 문자열을 넣거나
        const element = <div tabIndex="0"></div>;
        2. 중괄호 사이에 자바스크립트 코드를 넣는다. 
        const element = <img src={user.avatarUrl}></img>
    (childern 정의하기)
        태그 아래 하위태그가 생기면 자동적으로 children이 생성된다. 
    (index.js)
        
=====섹션 3에러
Uncaught TypeError: react_dom_client__WEBPACK_IMPORTED_MODULE_1__.render is not a function


강의에 나온 
ReactDOM.render(
   <React.StrictMode>
     <App />
   </React.StrictMode>,
   document.getElementById("root")
);
의 ReactDOM은 리액트 18버전부터 제공하지 않는다. 
그래서 설치시 기본으로 제공하는 root.render를 사용해서 실행시켜야한다. 

package.json에서 내 react 버전 확인하고 18버전이상이면
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <Library />
  </React.StrictMode>,
  document.getElementById("root")
);
기반으로 코드를 짜면 된다. 
=====섹션 4 : Rendering Elements
Element 란?
    뜻 : 요소/어떤 물체를 구성하는 성분
    smallest building blocks in react apps. 
    우리 눈에 실제로 보이는 것을 기술한다. 
React Element vs DOM Element
    DOM Elements는 Browser DOM을 사용하고, React Elements들은 Virtual DOM을 사용한다.
    리액트 엘리먼츠들은 렌더링하면 돔 엘리먼츠가 된다. 즉 우리가 보는 실제 엘리먼츠들은 돔 엘리먼츠다. 
    리액트 Elements 는 불변성을 가진 자바스크립트의 객체 형태로 존재한다.
props : <> 안의 id/ name 등의 attritube와 비슷하지만 그것보다 상위개념이다. 
Element 특징
    ***React elements are immutable*** 
    Elements 생성 후에는 children이나 attributes를 바꿀 수 없다. 
    하나의 Component를 통해 Element를 만들어낸다고 보면 된다. Class를 통해 instance를 생성하는 것과 비슷. 
    * 엘리먼트를 수정해야한다면 새로운 엘리먼트를 만들고 수정하고 싶은 엘리먼트와 바꾸면 된다. 
Elements렌더링하기
    Root DOM Node : <div id="root"></div> => 모든 리액트앱에 필수적으로 들어가는 중요한 노드다. 
                  : 리액트를 만드는 하나의 루트 돔 노드를 가지며, 여러개의 리액트 앱으로 구성되어있으면 여러개의 루트돔 노드로 만들어졌다. 
    * 엘리먼트를 수정해야한다면 새로운 엘리먼트를 만들고 수정하고 싶은 엘리먼트와 바꾸면 된다는 것 재차 강조
======섹션 5  Props 소개
동일하게 생긴 블록이라면 그것을 여러번 재사용해서 화면을 그리는 것이 리액트 
    js function과 react Component와 비슷하다. 
    함수에서 input과 output이 있다면
    React 의 input이 props, output이 React element다. 
    리액트는 객체지향의 Class와 instance처럼 붕어빵(Component) 틀과 붕어빵(Element)이라고 보면된다. 
Prop : Component의 Property라고 보면 된다. 
    prop이 팥이라면 팥붕 element, 슈크림이면 슈붕 element, 고구마면 고구마element다. 
    즉 Component의 속 재료라고 보면된다. 
    똑같은 모양의 사각현 컴포넌트안에 사진과 색상등은 모두 달라진다고 보면된다. 
Props의 특징 및 사용법 : 
    1. 특징 : Readonly (Immutable) 
        붕어빵이 다 구어진 이후에 속재료를 바꿀 수 없는 원리랑 똑같은것. 
        새로운 엘리먼트를 만들려면 새로운 값을 컴포넌트에 전달하여 새로 Element를 생성
        *pure한 함수란?
            입력값을 변경하지 않으며 같은 입력값에 대해서는 항상 같은 출력값을 리턴
            (ex) function sum(a+b){return a+b;}
        *impure한 함수
            function withdraw(account, amount){ account.total -= amount;}
        React는 pure하다 => 모든 리액트 컴포넌트는 props를 직접 바꿀 수 없고, 같은 props에 대해서는 항상 같은 결과를 보여준다. 
    2. Props 사용법
        Props: 컴포넌트에 전달할 다양한 정보를 담고 있는 객체
        그럼 컴포넌트에 props를 어떻게 전달할 수 있을까? 
        props에 문자열 이외의 값(정수, 변수, 다른 컴포넌트)이 들어갈 때는 {}로 감싸준다. 
        {}는 javascript 문법을 사용할 때 사용된다. 
====== 섹션5 : Component 만들기 
컴포넌트 : Function Component & Class Component 
    과거에는 Class Component를 사용했는데, 지금은 Hook을 사용한 Function Component를 사용한다. 
함수 컴포넌트 : 간단한다
    function Welcome(props){
        return <h1>안녕, {props.name}</h1>;
    }
클래스 컴포넌트 : React.Component를 상속받아 새로운 자식 클래스를 만드는 방식. 
    class Welcome extends React.Component{
        render(){
            return <h1>안녕, {this.props.name}</h1>
        }
    }
컴포넌트 이름짓기 : 항상 대문자로 시작해야한다. 
    이유 : 소문자로 시작하면 dom 태그(<div><span>)로 인식하기 때문. 소문자로 하면 컴파일하면서 에러가 날 것. 
컴포넌트 렌더링 : 컴포넌트는 붕어빵'틀' 이기 때문에 컴포넌트가 실제 화면에 보이지 않는다. 
                대신 컴포넌트를 통해 만든 엘리먼트가 눈에 보인다. 
                (예시)
                컴포넌트 생성
                function Welcome(props){
                    return <h1>안녕, {props.name}</h1> 
                }
                엘리먼트 생성
                const element = <Welcome name="인제" />
                렌더링 
                ReactDOM.render(
                    element, 
                    document.getElementById('root')
                )
컴포넌트 합성: React는 컴포넌트 안에 또 다른 컴포넌트를 넣을 수 있다. 
                function App(props){
                    return (
                        <div>
                            <Welcome name="Mike"/>
                            <Welcome name="Joe"/>
                            <Welcome name="Steve"/>
                        </div>
                    )
                }
컴포넌트 추출 : 컴포넌트 쪼개기
    장점 : 재사용성 상승, 개발속도 상승
=======섹션6 : State와 Lifecycle 정의
State : 리액트 컴포넌트의 변경 가능한 데이터 => 개발자가 정의한다. 
        * 렌더링이나 데이터 흐름에 사용되는 값만 state에 포함시켜야함. 
        왜냐하면 state가 변경될 경우 컴포넌트가 재렌더링 되기 때문에 
        불필요한 state 변경은 불필요한 재렌더링을 유도하기 때문. 
      : state는 Javascript 객체이다. 
      
      (ex)
      class LikeButton extends React.Component{
        constructor(props){  ==> 모든 class 컴포넌트 에는 constructor의 함수가 존재한다. 
            super(props);
            this.state = { ==> 이 부분이 현재 컴포넌트의 state. class 컴포넌트는 생성자 안에서 state에서 정의한다. 
                liked :false
            };
        }
      }
State 변경 : 재렌더링와 연결되어있기 때문에 절대 직접 수정하면 안됨
            .setState()를 통해 변경해야함. 
Lifecycle : 하나의 Component는 계속 같은 상태로 존재하지 않고, 
            시간의 흐름에 따라 생성되고 업데이트 되다가 사라진다. 
            (하지만 Class Component가 잘 사용되지 않는만큼, 이 라이프 사이클도 잘 사용되지 않는다. )
            
            - 출생 : Mouting => component의 constructor 실행 (componentDidMount())
            - 인생 : Updating => component의 render (componentDidUpdate())
            - 사망 : Unmounting => 상위 클래스에서 더 이상 하위 클래스를 표기하지 않을 때 component의 unmount (componentWillUnmount())

// 문제 1 : componentDidUpdate() 함수가 아예 실행되지 않음
// 문제 2 : 3번째 컴포넌트에 대한 건 출력이 안되고 있음
// 문제 3 : 1초 텀을 두고 1번과 2번이 출력되어야하는데 둘이 동시에 출력되고 있음. 

=========== 섹션 07. Hooks
React version16.8에서 새롭게 등장한 개념이나 지금은 모두 hook을 사용한다. 
Hook 이란? 
    Component 는 함수컴포넌트 / 클래스 컴포넌트가 있다. 함수 컴포넌트는 Class Component에 비해 코드가 간결해서 따로 state를 조정할 수 없었다. 
    그래서 등장한게 Hook이다. 
    원해진 시점에 정해진 함수를 수행하게끔 만들어진것이며, 
    hook의 규칙 중 하나는 앞에 use가 붙는다는 것이다. 
useState() : state를 사용하기 위한 Hook
    * 변수 각각에 대해 set함수가 따로 존재한다. 
    const [변수명, set함수명] = useState(초기값);   
    초기값 : 파라미터로 선언할 것 (생성자에서 setState하는 것과 동일)
        (ex)
        function Counter(props){
            const [count, setCount] = useState(0);
            return (
                <div>
                    <p>총 {count}번 클릭했습니다</p>
                    <button onClick
                </div>
            )
        }
useEffect() : sideEffect를 수행하기 위한 Hook
    리액트에서 얘기하는 side Effect는 효과를 의미한다. 이름이 이렇게 지어진 배경은 이펙트가 다른 컴포넌트에 영향을 미칠 수 있으며, 렌더링 중에는 완료될 수 없기 때문. 
    그래서 side로 진행되게끔 리액트의 함수 컴포넌트에서 side effect를 실행할 수 있게 해주는 hook
    componentDidMount(), componentWillUnmount(), componentDidUpdate() 함수를 하나로 합친거라고 보면 된다. 
    
    useEffect(이펙트 함수, 의존성 배열);
    의존성 배열이 하나라도 변경하면 바로 이펙트함수가 실행됨. 
    기본적으로 effect함수는 처음으로 컴포넌트가 렌더링된 초기 시점과 update로 인한 재렌더링 때에 실행된다. 
    의존성 배열을 생략하면 업데이트 될 때마다 재렌더링됨. 

useMemo() : Memoized value를 리턴하는 hook
    memoization : 최적화를 위해 사용되는 개념. 한번 호출된 결과를 저장해뒀다가 그 값을 바로 반환. 컴퓨터 자원을 적게쓸 수 있음. 
    * 렌더링이 진행되는 동안 실행된다. 그래서 렌더링이 일어나는 동안 실행되서는 안되는 함수를 넣어서는 안된다. 

    const memoizedValue = useMemo(
        () => {
            reutrn computeExpensiveValue(의존성변수1, 의존성변수2);
        },
        [의존성 변수1, 의존성 변수2]
    );

    의존성배열을 넣지 않으면 매 렌더링마다 함수가 실행됨. 
    의존성배열이 빈 배열일 경우, 컴포넌트 마운트 시에만 호출됨. 

useCallback() : useMemo() Hook과 유사하지만 값이 아닌 함수를 변환
    const memoizedCallback = useCallback(()=>{
        doSomething(의존성변수1, 의존성 변수2);
    },
    [의존성 변수1, 의존성 변수2]);

    아래 두 함수는 동일한 기능을 한다. 
    *useCallback(함수, 의존성배열);
    *useMemo(()=> 함수, 의존성배열);

useRef() : Reference(특정 컴포넌트에 접근할 수 있는 객체)를 반환
    refObject.current : 현재 참조하고 있는 Element의미
    (ex)
    const refContainer = useRef(초깃값);
    component mount해지전까지 계속 유지됨. 
    * useRef() Hook은 내부의 데이터가 변경되었을 때 별도로 알리지 않는다. 
Callback Ref를 사용해서 변경된 여부를 알람을 받는다. React는 다른 노드에 Callback를 실행하게 된다. 

=========== 섹션 07. Custom Hook
Custom Hook : 이름이 use로 시작하고 내부에서 다른 Hook을 호출하는 하나의 자바스크립트 함수
각 Custom Hook은 독립적 