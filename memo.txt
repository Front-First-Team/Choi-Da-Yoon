i처음만난리액트 
=====섹션0
- SPA : Single Page Application
매 페이지가 달리 있는게 아니라 그 안에 들어가는 콘텐츠를 바꿔끼는 것 
- Script Language : 
런타임에 따라 실행된다. 
- 일치 연산자
a===b : a와b가 값과 자료형 모두 같음
a!==b : a와b의 값은 같으나 자료형은 다름
- 함수
function statement :
    function name(){ return }
arrow function expression :
    const name = () => { return }
======섹션1
리액트란?
    2013년에 출시되었고, 지금은 JS에서 가장 많이 사용되는 UI 라이브러리다. 
    앵귤러는 더 이상 공식적인 지원이 끊겼다. 
    Vue는 2014년에 출시된 프레임워크
프레임워크 vs 라이브러리
프레임워크 : 제어권한이 프레임워크에 있고, 
라이브러리 : 제어권한인 개발자에게 있다. 
=====섹션3
- jsx의 정의와 역할
    jsx = js + xml/html 의 약자 
    예시 : const element = <h1> hello, world </h1>;
    const element라는 js와 <h1></h1> 라는 html이 결합된 것이 바로 jsx 다. 
- jsx의 역할과 사용 이유
    내부적으로 xml/html을 js로 변환되어 사용한다. 변환에 사용되는 것이 바로
    React.createElement() 다. 해당 함수의 결과를는 아래와 같은 객체가 생성된다. 
    const 변수명 = {
        type: 태그, 
        props : [{
            id:value
        }], 
        children : [{}]
    }

    - jsx 와 일반js 비교
    (jsx)
    const element = {
        <h1 className = 'greeting'>Hello, world!</h1>
    }
    (js)
    const element = React.createElement('h1', {className : 'greeting'}, 'Hello, world!' )

    React.createElement() 를 통해 jsx가 js변환된다는 것은, 리액트에서 반드시 jsx를 쓰지 않아도 된다는 것이다. 
    직접 js를 사용해서 개발해도 된다. 다만 jsx를 사용하면 훨씬 편리해진다. 
- jsx의 장점
    - 간결한 코드
    - 높은 가독성
    - injection attack 방어
- jsx 사용법
    html코드 사이에 js 문법을 사용하고 싶을 때 {} 를 통해 작성한다. 
    (예시)
        function formatUser(user){
            return user.firstname + '' + user.lastName;
        }
        const element = (
            <h1>Hello, {formatUser(user)}</h1>
        )
        ReactDOM.render(
            element, 
            document.getElementById('root')
        )
    (태크의 속성에 값을 넣는 방법)
        1. 큰따옴표 사이에 문자열을 넣거나
        const element = <div tabIndex="0"></div>;
        2. 중괄호 사이에 자바스크립트 코드를 넣는다. 
        const element = <img src={user.avatarUrl}></img>
    (childern 정의하기)
        태그 아래 하위태그가 생기면 자동적으로 children이 생성된다. 
    (index.js)
        
=====섹션 3에러
Uncaught TypeError: react_dom_client__WEBPACK_IMPORTED_MODULE_1__.render is not a function


강의에 나온 
ReactDOM.render(
   <React.StrictMode>
     <App />
   </React.StrictMode>,
   document.getElementById("root")
);
의 ReactDOM은 리액트 18버전부터 제공하지 않는다. 
그래서 설치시 기본으로 제공하는 root.render를 사용해서 실행시켜야한다. 

package.json에서 내 react 버전 확인하고 18버전이상이면
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <Library />
  </React.StrictMode>,
  document.getElementById("root")
);
기반으로 코드를 짜면 된다. 
=====섹션 4 : Rendering Elements
Element 란?
    뜻 : 요소/어떤 물체를 구성하는 성분
    smallest building blocks in react apps. 
    우리 눈에 실제로 보이는 것을 기술한다. 
React Element vs DOM Element
    DOM Elements는 Browser DOM을 사용하고, React Elements들은 Virtual DOM을 사용한다.
    리액트 엘리먼츠들은 렌더링하면 돔 엘리먼츠가 된다. 즉 우리가 보는 실제 엘리먼츠들은 돔 엘리먼츠다. 
    리액트 Elements 는 불변성을 가진 자바스크립트의 객체 형태로 존재한다.
props : <> 안의 id/ name 등의 attritube와 비슷하지만 그것보다 상위개념이다. 
Element 특징
    ***React elements are immutable*** 
    Elements 생성 후에는 children이나 attributes를 바꿀 수 없다. 
    하나의 Component를 통해 Element를 만들어낸다고 보면 된다. Class를 통해 instance를 생성하는 것과 비슷. 
    * 엘리먼트를 수정해야한다면 새로운 엘리먼트를 만들고 수정하고 싶은 엘리먼트와 바꾸면 된다. 
Elements렌더링하기
    Root DOM Node : <div id="root"></div> => 모든 리액트앱에 필수적으로 들어가는 중요한 노드다. 
                  : 리액트를 만드는 하나의 루트 돔 노드를 가지며, 여러개의 리액트 앱으로 구성되어있으면 여러개의 루트돔 노드로 만들어졌다. 
    * 엘리먼트를 수정해야한다면 새로운 엘리먼트를 만들고 수정하고 싶은 엘리먼트와 바꾸면 된다는 것 재차 강조
======섹션 5  Props 소개
동일하게 생긴 블록이라면 그것을 여러번 재사용해서 화면을 그리는 것이 리액트 
    js function과 react Component와 비슷하다. 
    함수에서 input과 output이 있다면
    React 의 input이 props, output이 React element다. 
    리액트는 객체지향의 Class와 instance처럼 붕어빵(Component) 틀과 붕어빵(Element)이라고 보면된다. 
Prop : Component의 Property라고 보면 된다. 
    prop이 팥이라면 팥붕 element, 슈크림이면 슈붕 element, 고구마면 고구마element다. 
    즉 Component의 속 재료라고 보면된다. 
    똑같은 모양의 사각현 컴포넌트안에 사진과 색상등은 모두 달라진다고 보면된다. 
Props의 특징 및 사용법 : 
    1. 특징 : Readonly (Immutable) 
        붕어빵이 다 구어진 이후에 속재료를 바꿀 수 없는 원리랑 똑같은것. 
        새로운 엘리먼트를 만들려면 새로운 값을 컴포넌트에 전달하여 새로 Element를 생성
        *pure한 함수란?
            입력값을 변경하지 않으며 같은 입력값에 대해서는 항상 같은 출력값을 리턴
            (ex) function sum(a+b){return a+b;}
        *impure한 함수
            function withdraw(account, amount){ account.total -= amount;}
        React는 pure하다 => 모든 리액트 컴포넌트는 props를 직접 바꿀 수 없고, 같은 props에 대해서는 항상 같은 결과를 보여준다. 
    2. Props 사용법
        Props: 컴포넌트에 전달할 다양한 정보를 담고 있는 객체
        그럼 컴포넌트에 props를 어떻게 전달할 수 있을까? 
        props에 문자열 이외의 값(정수, 변수, 다른 컴포넌트)이 들어갈 때는 {}로 감싸준다. 
        {}는 javascript 문법을 사용할 때 사용된다. 
====== 섹션5 : Component 만들기 
컴포넌트 : Function Component & Class Component 
    과거에는 Class Component를 사용했는데, 지금은 Hook을 사용한 Function Component를 사용한다. 
함수 컴포넌트 : 간단한다
    function Welcome(props){
        return <h1>안녕, {props.name}</h1>;
    }
클래스 컴포넌트 : React.Component를 상속받아 새로운 자식 클래스를 만드는 방식. 
    class Welcome extends React.Component{
        render(){
            return <h1>안녕, {this.props.name}</h1>
        }
    }
컴포넌트 이름짓기 : 항상 대문자로 시작해야한다. 
    이유 : 소문자로 시작하면 dom 태그(<div><span>)로 인식하기 때문. 소문자로 하면 컴파일하면서 에러가 날 것. 
컴포넌트 렌더링 : 컴포넌트는 붕어빵'틀' 이기 때문에 컴포넌트가 실제 화면에 보이지 않는다. 
                대신 컴포넌트를 통해 만든 엘리먼트가 눈에 보인다. 
                (예시)
                컴포넌트 생성
                function Welcome(props){
                    return <h1>안녕, {props.name}</h1> 
                }
                엘리먼트 생성
                const element = <Welcome name="인제" />
                렌더링 
                ReactDOM.render(
                    element, 
                    document.getElementById('root')
                )
컴포넌트 합성: React는 컴포넌트 안에 또 다른 컴포넌트를 넣을 수 있다. 
                function App(props){
                    return (
                        <div>
                            <Welcome name="Mike"/>
                            <Welcome name="Joe"/>
                            <Welcome name="Steve"/>
                        </div>
                    )
                }
컴포넌트 추출 : 컴포넌트 쪼개기
    장점 : 재사용성 상승, 개발속도 상승
    